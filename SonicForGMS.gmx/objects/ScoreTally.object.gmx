<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize
image_speed = 0;

state = 0;

scene_act = game_zone_get_act();

draw_set_font(global.GaslightFont);

var character_name = "SONIC";
var ring_count = 0;

continues_icon = ContinueSonicIconSprite;

player = game_player_find(0);

with (player) {
    ring_count = rings;
    switch (character_id) {
    case Tails:
        character_name = "TAILS";
        other.continues_icon = ContinueTailsIconSprite;
        break;
    case Knuckles:
        character_name = "KNUCKLES";
        other.continues_icon = ContinueKnucklesIconSprite;
        break;
    }
}

header_text1 = character_name + " GOT";
header_text2 = "THROUGH ACT";

header_screen_x1 = (camera_width * 0.5) - (string_width(header_text1) * 0.5);
header_screen_y1 = 56;

header_screen_x2 = (camera_width * 0.5) - (string_width(header_text2) * 0.5);
header_screen_y2 = 74;

act_screen_x = (camera_width * 0.5) + 88;
act_screen_y = 62;

score_label_screen_x = (camera_width * 0.5) - 104;
score_value_screen_x = (camera_width * 0.5) + 96;
continues_screen_x = score_value_screen_x + 16;
time_score_screen_x = score_label_screen_x + 13;
time_score_screen_y = 112;
ring_score_screen_x = score_label_screen_x + 12;
ring_score_screen_y = 128;
perfect_score_screen_x = score_label_screen_x;
perfect_score_screen_y = 144;
total_score_screen_x = score_label_screen_x + 33;
total_score_screen_y = 160;
continues_screen_y = total_score_screen_y - 6;

header_enter_speed = 16;
header_ox1 = ceil_to(header_screen_x1 + string_width(header_text1), header_enter_speed);
header_ox2 = ceil_to(camera_width - header_screen_x2, header_enter_speed);

score_value_enter_speed = 16;
time_score_ox = ceil_to(camera_width - score_label_screen_x, score_value_enter_speed);
ring_score_ox = time_score_ox + score_value_enter_speed;
perfect_score_ox = time_score_ox + (score_value_enter_speed * 2);
total_score_ox = time_score_ox + (score_value_enter_speed * 3);

continues_flash = 0;

game_audio_enqueue_music(ActCompletionMusic, 4, false);

delay_before_tally = 176;
delay_before_continue = 60;
delay_before_closing = 240;

wait_time = 60;

bonus_decrement = 100;

total_bonus = 0;

var total_time = 0;

with (ZoneTimeLimit) {
    total_time = (limit - count) div 60;
}

if (total_time &gt; 570) {
    time_bonus = 50000;
} else if (total_time &gt; 555) {
    time_bonus = 10000;
} else if (total_time &gt; 540) {
    time_bonus = 5000;
} else if (total_time &gt; 510) {
    time_bonus = 4000;
} else if (total_time &gt; 480) {
    time_bonus = 3000;
} else if (total_time &gt; 420) {
    time_bonus = 2000;
} else if (total_time &gt; 360) {
    time_bonus = 1000;
} else if (total_time &gt; 300) {
    time_bonus = 500;
} else {
    time_bonus = 0;
}

rings_bonus = ring_count * 10;

perfect_bonus = -1;
if (game_zone_get_total_rings() == 0) {
    perfect_bonus = 5000;
}

continues_count = 0;
if (time_bonus + rings_bonus + max(perfect_bonus, 0) &gt;= 10000) {
    continues_count++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle state
if (game_is_running()) {
    --wait_time;
    
    switch (state) {
    case 0: // wait a moment
        if (wait_time &lt;= 0) {
            ++state;
            if (header_ox1 &gt; header_ox2) {
                wait_time = (header_ox1 / header_enter_speed) + 1;
            } else {
                wait_time = (header_ox2 / header_enter_speed) + 1;
            }
        }
        break;
    
    case 1: // move header text
        if (header_ox1 &gt; 0) {
            header_ox1 -= header_enter_speed;
        }
        if (header_ox2 &gt; 0) {
            header_ox2 -= header_enter_speed;
        }
        if (wait_time &lt;= 0) {
            ++state;
            wait_time = delay_before_tally;
        }
        break;
    
    case 2: // move score value text
        if (time_score_ox &gt; 0) {
            time_score_ox -= score_value_enter_speed;
        }
        if (ring_score_ox &gt; 0) {
            ring_score_ox -= score_value_enter_speed;
        }
        if (perfect_score_ox &gt; 0) {
            perfect_score_ox -= score_value_enter_speed;
        }
        if (total_score_ox &gt; 0) {
            total_score_ox -= score_value_enter_speed;
        }
        if (wait_time &lt;= 0) {
            game_audio_play_sound(BeepSound, 0, true);
            ++state;
        }
        break;
    
    case 3: // apply scores
        var change;
        if (time_bonus) {
            change = min(time_bonus, bonus_decrement);
            time_bonus -= change;
            total_bonus += change;
            game_player_change_score(player, change);
        }
        if (rings_bonus) {
            change = min(rings_bonus, bonus_decrement);
            rings_bonus -= change;
            total_bonus += change;
            game_player_change_score(player, change);
        }  
        if (perfect_bonus) {
            change = min(perfect_bonus, bonus_decrement);
            perfect_bonus -= change;
            total_bonus += change;
            game_player_change_score(player, change);
        }
        if (not (time_bonus or rings_bonus or perfect_bonus)) {
            if (continues_count &gt; 0) {
                wait_time = delay_before_continue;
                ++state;
            } else {
                wait_time = delay_before_closing;
                state = 5;
            }
            audio_stop_sound(BeepSound);
            game_audio_play_sound(ChingSound, 0, false);
        }
        break;
    
    case 4: // continues
        if (wait_time &lt;= 0) {
            game_audio_play_sound(ContinueSound, 0, false);
            game_save_update_continues(1, game_save_current());
            wait_time = delay_before_closing;
            ++state;
        }
        break;
    
    case 5: // move on
        if (continues_count &gt; 0) {
            continues_flash++;
        }    
        if (wait_time &lt;= 0) {
            ++state;
            with (GamePlayer) {
                game_player_set_rings(self, 0);
                lives_via_rings = 0;
            }
            game_start_location_reset();
            game_zone_goto_next();
        }
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>203</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_kill_object</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw scorecard
if (view_current &lt; max_player_count) {
    var color = draw_get_color();
    var x1 = view_xview[view_current];
    var y1 = view_yview[view_current];

    if (scene_act &gt; 0) {
        draw_sprite(ZoneTitleS2ActSprite, scene_act - 1, x1 + act_screen_x + header_ox2, y1 + 62);
    }

    draw_background(TimeBonusScoreBack, x1 + time_score_screen_x + time_score_ox, y1 + time_score_screen_y);
    draw_background(RingBonusScoreBack, x1 + ring_score_screen_x + ring_score_ox, y1 + ring_score_screen_y);
    if (perfect_bonus &gt; -1) {
        draw_background(PerfectBonusScoreBack, x1 + perfect_score_screen_x + perfect_score_ox, y1 + perfect_score_screen_y);
    }
    draw_background(TotalBonusScoreBack, x1 + total_score_screen_x + total_score_ox, y1 + total_score_screen_y);

    if (continues_count &gt; 0 and state == 5 and (continues_flash div 16) mod 2 == 0) {
        draw_sprite(continues_icon, game_clock_get_step() div 22, x1 + continues_screen_x, y1 + continues_screen_y);
    }

    // header
    draw_set_font(global.GaslightFont);
    draw_set_halign(fa_left);
    draw_set_color(c_black);
    draw_text(x1 + header_screen_x1 - header_ox1 + 2, y1 + header_screen_y1 + 2, header_text1);
    draw_text(x1 + header_screen_x2 + header_ox2 + 2, y1 + header_screen_y2 + 2, header_text2);
    draw_set_color(c_white);
    draw_text(x1 + header_screen_x1 - header_ox1, y1 + header_screen_y1, header_text1);
    draw_text(x1 + header_screen_x2 + header_ox2, y1 + header_screen_y2, header_text2);

    // score values
    draw_set_font(global.HUDFont);
    draw_set_halign(fa_right);
    draw_text(x1 + score_value_screen_x + time_score_ox, y1 + time_score_screen_y + 1, time_bonus);
    draw_text(x1 + score_value_screen_x + ring_score_ox, y1 + ring_score_screen_y + 1, rings_bonus);
    if (perfect_bonus &gt; -1) {
        draw_text(x1 + score_value_screen_x + perfect_score_ox, y1 + perfect_score_screen_y + 1, perfect_bonus);
    }
    draw_text(x1 + score_value_screen_x + total_score_ox, y1 + total_score_screen_y + 1, total_bonus);
    draw_set_color(color);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>RhinoBotSprite</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Enemy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize
state = "patrolling";

x_speed = 3;

facing_sign = 1;
wall_sign = 0;
cliff_sign = 0;

x_radius = (bbox_right - xstart) + 1;
y_radius = (bbox_bottom - ystart) + 1;

timer = 30;

speed_cap = 3;
acceleration = 0.1;
deceleration = 3 / 29;

patrol_range_x = 75;
patrol_range_y = 30;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move on terrain (and animate)
if (game_is_running()) {
    var on_the_ground = false;
    
    var total = instance_number(Solid);
    var n, ind;
    
    wall_sign = 0;
    cliff_sign = 0;
    
    var sine = dsin(gravity_direction + 90);
    var cosine = dcos(gravity_direction + 90);
    
    x += cosine * x_speed;
    y += -sine * x_speed;
    
    var x2 = x + (cosine * x_radius) * facing_sign;
    var y2 = y - (sine * x_radius) * facing_sign;
    
    for (n = 0; n &lt; total; ++n) {
        ind = instance_find(Solid, n);
        if (game_shape_in_line(ind, x, y, x2, y2)) {
            wall_sign = sign(x_speed);
            break;
        }
    }

    x2 = x + (sine * y_radius);
    y2 = y + (cosine * y_radius);

    for (n = 0; n &lt; total; ++n) {
        ind = instance_find(Solid, n);
        if (game_shape_in_line(ind, x, y, x2, y2)) {
            on_the_ground = true;
            break;
        }
    }

    if (not on_the_ground and x_speed != 0) {
        cliff_sign = sign(x_speed);
        x -= cosine * x_speed;
        y -= -sine * x_speed;
    }

    image_xscale = facing_sign;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Patrol
if (game_is_running()) {
    if (state != "charging") {
        var x1 = x - patrol_range_x;
        var y1 = y - patrol_range_y;
        var x2 = x + patrol_range_x;
        var y2 = y + patrol_range_y;
        with (PlayableCharacter) {
            if (point_in_rectangle(x_int, y_int, x1, y1, x2, y2)) {
                other.state = "charging";
                other.x_speed = 0;
                other.facing_sign = sign(x - other.x);
                other.timer = 60;
                other.image_index = 0;
                break;
            }
        }
    }

    /*
    for (var n = 0; n &lt; instance_number(PlayableCharacter); ++n) {
        ind = instance_find(PlayableCharacter, n);
        if (point_in_rectangle(ind.x_int, ind.y_int, x - patrol_range_x, y - patrol_range_y, x + patrol_range_x, y + patrol_range_y)) {
            if (state != "charging") {
                state = "charging";
                x_speed = 0;
                facing_sign = sign(ind.x - x);
                timer = 60;
                image_index = 0;
            }
            break;
        }
    }
    */
    
    switch (state) {
    case "patrolling":
        if (facing_sign == wall_sign or facing_sign == cliff_sign) {
            state = "turning";
            x_speed = 0;
            wall_sign = 0;
            cliff_sign = 0;
            timer = 10;
            image_index = 2;
            break;
        }

        --timer;

        if (timer &lt;= 0) {
            state = "braking";
            image_index = 1;
            break;
        }

        if (abs(x_speed) &lt; speed_cap) {
            x_speed += acceleration * facing_sign;
            if (abs(x_speed) &gt; speed_cap) {
                x_speed = speed_cap * facing_sign;
            }
        }
        break;

    case "braking": // braking
        if (facing_sign == wall_sign or facing_sign == cliff_sign) {
            x_speed = 0;
        }

        if (x_speed == 0) {
            state = "turning";
            wall_sign = 0;
            cliff_sign = 0;
            timer = 10;
            image_index = 2;
            break;
        }

        if (abs(x_speed) &gt; 0) {
            x_speed -= min(abs(x_speed), deceleration) * sign(x_speed);
        }
        break;

    case "turning":
        --timer;

        if (timer &lt;= 0) {
            state = "patrolling";
            facing_sign = -facing_sign;
            timer = 60;
            image_index = 0;
        }
        break;

    case "charging":
        if (facing_sign == wall_sign or facing_sign == cliff_sign) {
            state = "turning";
            x_speed = 0;
            wall_sign = 0;
            cliff_sign = 0;
            timer = 10;
            image_index = 2;
            break;
        }

        if (timer &gt; 0) {
            --timer;
            if (timer == 30) {
                x_speed = 5 * facing_sign;
            }
            if (timer == 0) {
                state = "braking";
                image_index = 0;
            }
        }
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>500</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring>draw_self();</codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw charging dust
if (state == "braking" or (state == "charging" and timer &gt; 30)) {
    draw_sprite_ext(RhinoBotDustSprite, game_clock_get_step() div 3, x, y, image_xscale, image_yscale, image_angle, image_blend, image_alpha);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
